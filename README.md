<a href="https://auteddy.itch.io" target="_blank">
  <img src="./images/Godot_EventBridgeLogo.svg" />
</a>

<p align="center">
  <a href="https://auteddy.itch.io" target="_blank">
    <img src="https://img.shields.io/badge/Buy_on-itch.io-red?style=for-the-badge&logo=itchdotio&labelColor=black" alt="Buy on itch.io" />
  </a>
  <a href="https://ko-fi.com/M4M51IR6VN" target="_blank">
    <img src="https://img.shields.io/badge/Support_me_on_Ko_Fi-blue?style=for-the-badge&logo=kofi&label=%20&labelColor=%23000&color=%23000" alt="Ko-fi" />
  </a>
</p>
<p align="center">
  <img src="https://img.shields.io/badge/godot-Editor_Plugin-blue?style=for-the-badge&logo=godotengine&color=%23000000" alt="Godot Editor Plugin" />
  <img src="https://img.shields.io/badge/godot-Signals-blue?style=for-the-badge&logo=godotengine&color=%233176BB" alt="Godot Signals" />
  <img src="https://img.shields.io/badge/godot-RPC-green?style=for-the-badge&logo=godotengine&color=%23008C3C" alt="Godot RPC" />
</p>
<p align="center">
  <a href="https://discord.com/channels/1399270391226175518" target="_blank">
    <img src="https://img.shields.io/discord/1399270391226175518?style=for-the-badge&logo=discord" alt="Discord Chat" />
  </a>
</p>

---

# ðŸŽ¯ EventBridge for Godot 4

> **Supported Godot Engine:** **4.4.x**

EventBridge gives you a clean, scalable, **multiplayerâ€‘ready** eventâ€‘driven architecture for Godot 4.  
Perfect for singleâ€‘player **and** multiplayer projects where raw signals/RPCs get messy.

- âœ… **Autogenerated API** â€“ No more manual signal connections
- âœ… **Multiplayerâ€‘Ready** â€“ `to_server`, `to_all`, `to_id`, `emit_local`
- âœ… **Editor Integration** â€“ Visual Event Registry & 1â€‘click API generation (EventDock)
- âœ… **One Source of Truth** â€“ All events live in `event_registry.json`

---

## ðŸ“š Table of Contents

- [Why EventBridge?](#-why-choose-eventbridge)
- [Multiplayer Targets](#-perfect-for-multiplayer)
- [Getting Started](#-getting-started)
- [Installation](#-installation)
- [Quick Example Registry](#-quick-example-event-registry)
- [Usage](#-usage)
- [API Reference](#-full-api)
- [EventBridge vs RPC](#eventbridge-isnt-a-replacement-for-rpc)
- [Sideâ€‘byâ€‘Side Example](#side-by-side-example)
- [Performance Note](#performance-note)
- [License](#-license)
- [Roadmap](#-roadmap)
- [Community](#-join-the-community)
- [Support](#-enjoy-using-event-bridge-please-support-development)

---

## âœ… Why EventBridge?

- **Local & Network Events** â€“ One API for local, server, peerâ€‘specific, or broadcast events.  
- **Namespaces for Organization** â€“ Keep events modular and maintainable.  
- **Automatic Event Registry** â€“ Define once, reuse everywhere.  
- **Editor Integration** â€“ Manage events visually with the EventDock panel.  
- **Duplicate Protection** â€“ No more double signal connections.  
- **Persistent Caching** â€“ Fast lookups even for large projects.  
- **Oneâ€‘Line Cleanup** â€“ `off_all()` removes dangling handlers.

---

## ðŸŽ® Perfect for Multiplayer

Send events: **to the server**, **to all peers**, or **to a specific peer**.

```gdscript
var ns := EventBridge.get_namespace("Lobby")

ns.on("ping", func(msg):
    print("PING:", msg)
)

# Client asks server to handle/rebroadcast:
ns.to_server("pong", ["Hello from CLIENT %d" % multiplayer.get_unique_id()])

# Or server broadcasts:
if multiplayer.is_server():
    ns.to_all("ping", ["Hello from SERVER"])
```

---

## ðŸš€ Getting Started

Follow the **Developer Guide** to configure your first events, generate the API, and test in minutes.  
If youâ€™re using the demo project, open the EventDock and press **Generate** to create the initial registry and wrappers.

---

## ðŸ“¦ Installation

1. Copy the **`addons/event_bridge`** folder into your Godot project.  
2. Enable the plugin in **Project â†’ Project Settings â†’ Plugins**.  
3. Add **`event_bus.gd`** as an **Autoload Singleton**:  
   - **Name:** `EventBridge`  
   - **Path:** `res://addons/event_bridge/event_bus.gd`  
4. Open the **EventDock**, create namespaces/events, then click **Generate**.

> Tip: Commit the generated files (`event_registry.json`, `EventManager.gd`, etc.) so your **server and clients** share the same version.

---

## âš¡ Quick Example Event Registry

`event_registry.json` is automatically generated from the EventDock tree.  
You can also copy `event_data.tres` to bootstrap another project with the same events.

```json
{
  "Test": [
    { "name": "ping", "rpc": "remote", "args": ["msg"] },
    { "name": "pong", "rpc": "remote", "args": ["msg"] }
  ]
}
```

---

## ðŸ›  Usage

### 1) Get a Namespace
```gdscript
var ns := EventBridge.get_namespace("Test")
```

### 2) Subscribe to Events
```gdscript
ns.on("ping", func(msg):
    print("[CLIENT] PING:", msg)
    ns.to_server("pong", ["Hello from CLIENT %d" % multiplayer.get_unique_id()])
)
```

### 3) Emit Events (Server)
```gdscript
if multiplayer.is_server():
    await get_tree().create_timer(2.0).timeout
    ns.to_all("ping", ["Hello from SERVER"])
```

### âœ… Cleanup
```gdscript
func _exit_tree() -> void:
    ns.off_all()
```

> Prefer **serverâ€‘authoritative** flows. Clients **request** (`to_server`), server **validates** and **broadcasts** (`to_all` / `to_id`).  
> Add perâ€‘event validators like `func validate_request_roll(args: Array) -> bool:` for extra safety.

---

## ðŸ”‘ Full API

**Namespace API (via `EventBridge.get_namespace()`):**

| Method | Description |
|---|---|
| `get_namespace(name)` | Returns a Namespace handle for `name`. |
| `on(event, callable)` | Subscribe to an event. |
| `off(event, callable)` | Unsubscribe a specific callback. |
| `off_all()` | Remove all handlers for the namespace. |
| `emit_local(event, args := [])` | Emit only on the local peer (no network). |
| `to_server(event, args := [])` | Send to server (authority). |
| `to_all(event, args := [])` | Broadcast to all peers. |
| `to_id(id, event, args := [])` | Send to a specific peer. |
| `only_me(event, args := [])` | Emit only on this client (utility for local UX). |

**Generated API (via `EventManager.gd`, if enabled):**
- Typed facades like `EventManager.dice_broadcast(player_id, result)`
- Listener helpers like `EventManager.on_dice_broadcast(cb)` / `off_dice_broadcast(cb)`

> Names depend on your generator template. If wrappers are not generated, use the Namespace API.

---

## ðŸ“„ License

**EventBridge Plugin â€” Custom Commercial License**

**You may:**
- Use in unlimited personal & commercial Godot projects.
- Modify the plugin for your own projects.

**You may not:**
- Distribute, share, or resell the plugin (original or modified).
- Include this plugin in asset packs or templates (free or paid).
- Remove copyright notices or claim ownership of the original code.

**Liability:** Provided *asâ€‘is*, without warranties. The author is not responsible for any damages arising from use.

---

## ðŸ›£ Roadmap

- [ ] Richer GUI editor for event registry (advanced filtering/search)  
- [ ] Argument validation on emit (generator hints)  
- [ ] Type hints for callable arguments / generated stubs  

---

## ðŸ’¬ Join the Community

[![Discord](https://img.shields.io/discord/1399270391226175518?style=for-the-badge&logo=discord)](https://discord.com/channels/1399270391226175518)

---

## ðŸ’– Enjoy using EventBridge? Please support development

If you enjoy using EventBridge, consider supporting my work on Koâ€‘Fi or buying on itch.io.

<a href="https://ko-fi.com/M4M51IR6VN" target="_blank">
  <img src="https://img.shields.io/badge/Support_me_on_Ko_Fi-blue?style=for-the-badge&logo=kofi&label=%20&labelColor=%23000&color=%23000" alt="Koâ€‘Fi" />
</a>
<br/><br/>
<a href="https://auteddy.itch.io" target="_blank">
  <img src="https://img.shields.io/badge/Buy_on-itch.io-red?style=for-the-badge&logo=itchdotio&labelColor=black" alt="itch.io" />
</a>

---

## EventBridge isnâ€™t a replacement for RPC

Itâ€™s a higherâ€‘level layer that uses Godotâ€™s multiplayer/RPC under the hood and adds structure (**namespaces**), **generated APIs**, **validation**, and **logging**.

### What EventBridge adds (on top of RPC)

- **Namespaceâ€‘based bus:** Groups events (e.g., `Game`, `Lobby`) and emits signals.  
- **Generated faÃ§ade:** `EventManager.gd` helpers like `dice_broadcast(pid, result)`, `on_dice_broadcast(cb)`, `off_dice_broadcast(cb)`.  
- **Perâ€‘event RPC config:** Authority (`authority`/`any_peer`), sync (`call_remote`/`call_local`), transfer mode (`reliable` / `unreliable` / `unreliable_ordered`), and channel â†’ mapped at dispatch.  
- **Validation hooks:** Central/perâ€‘event validators run before dispatch.  
- **Logging & tooling:** Consistent logs and the EventDock for visibility.

### What it does not replace

- **Transports:** ENet/WebSocket/WebRTC are still the pipes.  
- **Authority rules:** Node ownership, `MultiplayerAPI` modes, and peer authority still apply.  
- **State replication:** Use `MultiplayerSynchronizer` for continuous state; EventBridge focuses on **discrete events**.  
- **Lowâ€‘level edge cases:** Custom binary streams or bespoke reliability semantics still belong to raw RPC/peers.

### When to use which

Use **EventBridge** for gameplay **events** and crossâ€‘cutting signals (joins, chat, turns, combat results), where you want consistency, validators, and easy subscribe/unsubscribe.  
Use **raw RPC** for ultraâ€‘tight loops, custom replication, or very specific authority/serialization needs.  
Mixing is fine.

---

## Side-by-side example

### Raw RPC
```gdscript
# server.gd
@rpc("any_peer", "call_remote", "reliable")
func rpc_dice_broadcast(player_id: int, result: int) -> void:
    print("DICE:", player_id, result)

func broadcast_result(player_id: int, result: int) -> void:
    rpc("rpc_dice_broadcast", player_id, result)
```

### EventBridge
```gdscript
# Generated API (EventManager.gd)
EventManager.dice_broadcast(player_id, result)   # to_all / reliable / channel 0
EventManager.on_dice_broadcast(func(pid, res):
    print("[EB] DICE:", pid, res)
)
```

Functionally they do the same thing; EventBridge standardizes the call site, applies validators, sets the correct RPC mode/channel, and wires up the signal for you.

---

## Performance note

EventBridge adds light overhead (lookups, signal emission, validation). The heavy work (serialization/delivery) is still Godotâ€™s networking, so performance is dominated by transport and payload size.

---

**TL;DR**: EventBridge is a structured, safer abstraction over RPC, not a replacement. It keeps gameplay code clean while relying on Godotâ€™s networking stack.
